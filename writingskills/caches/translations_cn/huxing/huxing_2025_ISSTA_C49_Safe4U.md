# Safe4U: Identifying Unsound Safe Encapsulations of Unsafe Calls in Rust using LLMs
# Safe4U：利用大语言模型识别Rust中不健全的安全封装

**来源**: ISSTA 2025 | **作者**: Huan Li 等

## 摘要
Rust通过严格的编译时检查确保安全性，但unsafe函数具有额外的安全要求（即合约），需要调用者保证。社区推荐使用安全封装（EUC）来复用和减少unsafe代码，但如果合约未被保证，EUC就是不健全的，可能导致安全Rust中的未定义行为。由于跨语言理解代码和自然语言的局限性，传统技术难以识别不健全的EUC。本文提出Safe4U框架，结合LLM、静态分析工具和领域知识来识别不健全的EUC。Safe4U首先利用静态分析检索相关上下文，然后将冗长的Safety描述分解为细粒度分类合约，最后引入领域知识调用LLM推理能力验证每个合约。评估结果表明Safe4U能识别CVE中11个不健全EUC中的9个，并在最常下载的crate中发现22个新的不健全EUC，其中16个已被确认。

## 引言核心
- Rust的unsafe函数合约以非结构化自然语言写在Safety文档中，传统形式化验证和静态分析难以处理
- 不健全的EUC可能通过函数调用和数据流广泛传播，导致复杂缺陷甚至隐藏漏洞
- LLM直接应用效果不佳：Safety描述冗长复杂、缺乏EUC相关上下文、缺少领域知识导致低准确率
- 初步研究总结了16种合约类型和34种保证模式，覆盖内存与指针、值、并发、生命周期等多个维度
- 现有无数据集可用于识别不健全EUC，且难以创建足够样本的新数据集

## 方法概述
Safe4U包含三个模块。上下文检索模块（Context Retrieval）部署静态分析工具与编译器协作，检索目标EUC的上下文信息（包括Safety文档）。分解与分类模块（Decomposition & Classification）利用LLM将冗长的Safety描述分解为多个细粒度合约，并将每个合约分类到预定义的合约类型中。通过分解，细粒度合约可以独立检查，显著降低识别难度；通过分类，Safe4U可以动态选择包含特定领域知识的示例。

模式导向检查模块（Pattern-Oriented Checks）将示例添加到提示中，利用LLM的上下文学习和推理能力检查合约。最终，所有细粒度合约的结果被聚合：如果任一合约被识别为"未保证"，则该EUC被认为是不健全的。作者还提出了从安全封装中模拟不健全样本的方法来构建评估数据集。

## 关键实验发现
- RQ1（整体性能）：Safe4U在所有LLM上均优于基线方法，体现了有效性和通用性
- RQ2（细粒度定位）：Safe4U能定位需要修复的具体未保证合约
- RQ3（CVE验证）：Safe4U成功识别CVE中11个不健全EUC中的9个
- RQ4（实际扫描）：在最常下载的crate中扫描2,849个EUC和1,409个不同unsafe API，发现22个不健全EUC，16个已被确认修复

## 写作特征备注
- 标题结构：工具命名型（"Safe4U" + 任务描述 + 技术手段）
- 摘要是否有数字：是（9/11、22、16、2,849、1,409等）
- 是否有RQ：是（通过评估设计隐含多个RQ）
- 是否有Motivating Example：是（Figure 1展示sound和unsound EUC的对比示例）
- 贡献点数量：4

## 结论
Safe4U首次将LLM引入Rust不健全EUC识别任务，通过结合静态分析、合约分解和领域知识有效提升了LLM的识别能力，在真实场景中发现并确认了16个新的不健全封装，为维护Rust安全承诺提供了实用工具。
