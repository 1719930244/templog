# SelfPiCo: Self-Guided Partial Code Execution with LLMs
# SelfPiCo：基于大语言模型的自引导部分代码执行

**来源**: ISSTA 2024 | **作者**: Zhipeng Xue 等

## 摘要
代码可执行性在软件调试和测试中至关重要，但部分代码执行因缺少定义和复杂的第三方依赖而极具挑战。现有工具Lexecutor使用机器学习预测未定义元素类型并注入预定义虚拟值，但性能有限。本文提出SelfPiCo框架，通过将开源LLM（Code Llama）嵌入交互循环（LLM-in-the-loop），动态引导部分代码执行。SelfPiCo利用少样本上下文学习和思维链推理，持续从执行结果中学习并逐步优化预测。评估表明SelfPiCo在开源代码和Stack Overflow代码片段上分别执行了72.7%和83.3%的代码行，超越Lexecutor 37.9%和33.5%，并成功检测到18个和33个运行时类型错误。

## 引言核心
- 75%的代码片段无法直接执行（缺少变量/函数定义、第三方依赖），限制了代码复用和动态分析
- Lexecutor的两个关键局限：预定义虚拟值过于简单无法覆盖实际场景；无法从执行结果中交互式学习
- 熟练开发者能从失败执行结果中获取洞察并逐步优化预测，启发了LLM-in-the-loop的设计
- 首次引入LITL（LLM-in-the-loop）概念，区别于传统的HITL（Human-in-the-loop）
- 部分代码执行与自动程序修复（APR）有本质区别：目标不同（使代码可执行vs通过所有测试），交互方式不同（注入缺失值vs修改原始代码）

## 方法概述
SelfPiCo包含三个核心组件。交互式值预测器是核心模块，包括交互式值生成器和执行值检查器：值生成器为缺失元素生成可能的值，检查器验证生成值的有效性，若执行失败则将错误信息反馈给生成器重新生成，形成交互循环。

补充类型预测器作为交互式值预测器的补充，处理超过最大迭代次数的情况——当值预测器无法预测合适值时，类型预测器预测缺失元素的类型并注入预定义虚拟值。运行时引擎负责对部分代码进行插桩，捕获执行异常，并注入来自交互式值预测器的值以引导代码执行。SelfPiCo基于微调的Code Llama模型，性能接近闭源商业GPT-3.5模型。

## 关键实验发现
- RQ1（代码覆盖率）：SelfPiCo在开源项目函数和SO代码片段上分别执行72.7%和83.3%的代码行，超越Lexecutor 37.9%和33.5%
- RQ2（完全执行率）：在开源项目上完全执行率提升62.6%，在SO代码片段上提升57.7%
- RQ3（实际应用）：成功从8个GitHub项目检测到18个运行时类型错误，从43个SO帖子检测到33个类型错误
- 微调的开源Code Llama模型在部分代码执行任务上性能接近闭源GPT-3.5

## 写作特征备注
- 标题结构：工具名+任务描述（SelfPiCo: Self-Guided Partial Code Execution with LLMs）
- 摘要是否有数字：是（72.7%、83.3%、37.9%、33.5%、18个、33个错误）
- 是否有RQ：否（通过评估问题组织但未明确编号为RQ）
- 是否有Motivating Example：是（Section 2通过Luigi项目的类型错误展示使用场景）
- 贡献点数量：3

## 结论
SelfPiCo通过LLM-in-the-loop的创新设计，实现了从执行结果中持续学习的部分代码执行框架，显著提升了代码覆盖率，并在运行时类型错误检测中展现了实际应用价值。
